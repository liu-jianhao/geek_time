# 09 | 普通索引和唯一索引，应该怎么选择?


## change buffer
- 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，**InooDB 会将这些更新操作缓存在 change buffer 中**，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的 时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方 式就能保证这个数据逻辑的正确性。
- 将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问 这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭 (shutdown)的过程中，也会执行 merge 操作。
- 显然，如果能够将更新操作先记录在 change buffer，**减少读磁盘，语句的执行速度会得到明显的提升**。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占 用内存，提高内存利用率。

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。

因此，**唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用**。

因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录 的变更动作缓存下来，**所以在一个数据页做 merge 之前，change buffer 记录的变更越多 (也就是这个页面上要更新的次数越多)，收益就越大。**

- 对于**写多读少**的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。
- 假设一个业务的更新模式是**写入之后马上会做查询**，那么即使满足了条件，将更新 先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。 这样随机访问 IO 的次数不会减少，**反而增加了 change buffer 的维护代价**。所以，对于这 种业务模式来说，change buffer 反而起到了副作用。


## 小结
由于唯一索引用不上 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发建议优先考虑非唯一索引。
